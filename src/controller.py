from typing import List
import json
from langchain.tools import StructuredTool

from src.retrievers.table_data_retriever import TableDataRetriever
from src.datastores.sqlstores.metastore import MetaStore
from src.retrievers.base import BaseRetriever
from src.retrievers import VectorRetriever
from src.tasks import QATask
from src.utils.llm import DEFAULT_LLM
from src.utils.generate_args_schema import generate_args_schema_from_method
from src.utils.logging_config import setup_logger
from src.tasks.base import BaseTask

from langchain_core.prompts import HumanMessagePromptTemplate, ChatPromptTemplate
from langchain_core.messages import HumanMessage, SystemMessage

from src.utils.prompts import TASK_SELECTION_PROMPT, DATA_SOURCE_SELECTION_PROMPT, CONTROLLER_PROMPT
from src.utils.helpers import extract_json_blocks, format_dataset_info, format_tool_metadata

logger = setup_logger(__name__)

class ControllerAgent:
    def __init__(
            self,
            tasks: List[BaseTask] = [QATask()],
            retrievers: List[BaseRetriever] = [VectorRetriever()]
    ):
        self.tasks = tasks
        self.retrievers = retrievers
        self.llm = DEFAULT_LLM
        


    def invoke(self, query):
        tasks = self._select_tasks(query=query)
        if not tasks:
            return "Unable to select task"
        logger.info(f"Tasks to perform: {[task.name for task in tasks]}")

        datasets = self._select_relevant_data(query=query)
        if not datasets:
            return "Unable to select dataset"
        logger.info(f"Relevant datasets selected: {[dataset_info.name for dataset_info in datasets]}")

        selected_retrievers = self._select_retrievers(dataset_info=datasets)
        if not selected_retrievers:
            return "Unable to select retriever"
        logger.info(f"Retriever selected: {[retriever.name for retriever in selected_retrievers]}")

        # Create tools
        tools_dict = {}

        for retriever in selected_retrievers:
            retriever_tool = StructuredTool.from_function(
                func=retriever.retrieve,
                name=retriever.name,
                description=f"Type: `retriever tool`\n{retriever.description}",
                args_schema=generate_args_schema_from_method(retriever.retrieve)
            )
            tools_dict[retriever.name] = retriever_tool

        for task in tasks:
            task_tool = StructuredTool.from_function(
                func=task.execute,
                name=task.name,
                description=f"Type: `task tool`\n{task.description}",
                args_schema=generate_args_schema_from_method(task.execute)
            )
            tools_dict[task.name] = task_tool

        def call_tool(tool_name, args):
            logger.debug(f"Tool `{tool_name}` Called with args: {args}")
            return tools_dict[tool_name].invoke(args)

        def final_answer(answer: str):
            return answer

        tool_metadata = format_tool_metadata(tools_dict)
        dataset_metadata = format_dataset_info(datasets)

        # Create messages using classes instead of raw dicts
        messages = [
            SystemMessage(
                content=CONTROLLER_PROMPT + f"""
Available tools:
{tool_metadata}

Relevant datasets:
{dataset_metadata}
"""
            ),
            HumanMessage(content=query)
        ]

        for _ in range(10):
            try:
                tool_call_msg = self.llm.invoke(messages)
                tool_call = extract_json_blocks(tool_call_msg.content)
            except Exception as e:
                logger.exception("Failed to parse tool call")
                error = f"Error parsing tool call: {e}"
                messages.append(tool_call_msg)
                messages.append(HumanMessage(name=tool_name, content=f"Error: {error}\n Original User query was : {query}"))
                continue

            tool_name = tool_call.get("tool")
            args = tool_call.get("args", {})

            if tool_name == "final_answer":
                answer = args.get("answer", "")
                logger.info(f"Final answer generated by controller: {answer}")
                return answer

            if tool_name not in tools_dict:
                logger.error(f"Unknown tool called: {tool_name}")
                tool_output = "Unknown tool called: {tool_name}"
            else:
                try:
                    tool_output = call_tool(tool_name, args)
                    logger.info(f"{tool_name} output: {tool_output}")
                except Exception as e:
                    logger.exception(f"{tool_name} tool execution failed")
                    tool_output = f"Error executing {tool_name} tool: {e}"
            messages.append(tool_call_msg)
            messages.append(HumanMessage(name=tool_name, content=f"Tool Output: {tool_output}\n Original User query was : {query}"))

        
    def _select_tasks(self, query):
        task_list = [
            {"name": task.name, "description": task.description} for task in self.tasks
        ]
        messages = ChatPromptTemplate.from_messages(
            [
                SystemMessage(TASK_SELECTION_PROMPT),
                HumanMessagePromptTemplate.from_template("Query: {query}\n Tasks and Description:\n ```json\n{task_list}\n```")
            ]
        ).format_messages(query=query, task_list=task_list)
        llm_resp = DEFAULT_LLM.invoke(messages).content
        result = extract_json_blocks(llm_resp)
        relevant_tasks = []
        for task in self.tasks:
            for selected_task in result['tasks']:
                if task.name == selected_task:
                    relevant_tasks.append(task)
            
        return relevant_tasks
    


    def _select_relevant_data(self, query):
        meta_store = MetaStore()
        all_data = meta_store.fetch_all()
        data_list = []
        seen = set()
        for data in all_data:
            item = (data.name, data.description)
            if item not in seen:
                seen.add(item)
                data_list.append({"name": data.name, "description": data.description})

        messages = ChatPromptTemplate.from_messages(
            [
                SystemMessage(DATA_SOURCE_SELECTION_PROMPT),
                HumanMessagePromptTemplate.from_template("Query: {query}\n Datasets and Description:\n ```json\n{data_list}\n```")
            ]
        ).format_messages(query=query, data_list=data_list)
        llm_resp = DEFAULT_LLM.invoke(messages).content
        result = extract_json_blocks(llm_resp)
        relevant_data_sources = []

        for data in all_data:
            for selected_data in result['data_sources']:
                if data.name == selected_data and data not in relevant_data_sources:
                    relevant_data_sources.append(data)
        return relevant_data_sources

    def _select_retrievers(self, dataset_info):
        selected_retrievers = []
        for retriever in self.retrievers:
            for dataset in dataset_info:
                if retriever.data_store.source_data_type == dataset.data_type:
                    selected_retrievers.append(retriever)
        return selected_retrievers
       

