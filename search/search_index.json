{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgenticRAG","text":""},{"location":"#introduction","title":"Introduction","text":"<p>AgenticRAG is a comprehensive library for building flexible Retrieval-Augmented Generation (RAG) systems. It provides a modular architecture that allows developers to customize each component according to their specific requirements while maintaining compatibility across the system.</p> <p>This library solves several key challenges in building RAG applications: - Managing diverse data types (text, tables, databases) through a unified interface - Simplifying data ingestion from various sources - Providing flexible retrieval mechanisms adapted to different data types - Supporting multiple downstream tasks using retrieved context - Enabling easy customization at any level of the stack</p>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>The AgenticRAG system follows a modular, layered architecture where each component has specific responsibilities:</p> <ol> <li>Data Storage Layer: Stores maintain structured representations of various data types</li> <li>Data Ingestion Layer: Loaders and Connectors handle importing data into stores</li> <li>Data Retrieval Layer: Retrievers access relevant information based on queries</li> <li>Task Execution Layer: Tasks perform operations using retrieved context</li> <li>Orchestration Layer: RAGAgent coordinates all components to fulfill user requests</li> </ol> <p>This design follows key principles: - Separation of concerns: Each component handles distinct responsibilities - Extensibility: Custom implementations can be created for any component - Loose coupling: Components interact through well-defined interfaces - Progressive disclosure: Simple use cases are easy, while complex customization is possible</p>"},{"location":"01_stores/","title":"Stores","text":"<p>Stores form the foundation of the AgenticRAG system, providing a consistent way to manage various data types. Each store is specialized for a particular data format and typically connects to a storage backend.</p>"},{"location":"01_stores/#available-storage-backends","title":"Available Storage Backends","text":"<p>The library provides two built-in storage backends: - SQLBackend: Uses relational databases for structured data storage - ChromaBackend: Uses vector databases for embedding-based retrieval</p> <p>You can implement custom backends by inheriting from the <code>BaseBackend</code> abstract class and implementing methods for CRUD.</p> <pre><code>from agenticrag.stores import BaseBackend\nfrom agenticrag.types import BaseData\n\nclass MyCustomBackend(BaseBackend[SchemaType]):\n    def __init__(self, schema: Type[SchemaType]...):\n        # Implement Your logic\n\n    def add(self, data):\n        # Implement adding data\n        pass\n\n    def get(self, id):\n        # Implement data retrieval\n        pass\n\n    # Implement other required methods\n</code></pre> <p>To make store for specific type of data, you can inherit any of the backend as required and implement with specific schema, model or other parameters as required.</p>"},{"location":"01_stores/#core-store-types","title":"Core Store Types","text":"<p>The library includes four primary store types:</p>"},{"location":"01_stores/#metastore","title":"MetaStore","text":"<p>Maintains metadata about all datasets, essential for decision-making by the RAGAgent.</p> <pre><code>from agenticrag.stores import MetaStore\nfrom agenticrag.types import MetaData, DataFormat\n\n# Initialize metastore\nmeta_store = MetaStore(connection_url=\"sqlite:///agenticrag.db\")\n\n# Add dataset metadata\nmeta_store.add(\n    MetaData(\n        name=\"company_docs\",\n        format=DataFormat.TEXT,\n        description=\"Internal company documentation\",\n        tags=[\"internal\", \"documentation\"]\n    )\n)\n\n# Query metadata\ntext_datasets = meta_store.filter(format=DataFormat.TEXT)\n</code></pre>"},{"location":"01_stores/#textstore","title":"TextStore","text":"<p>Manages text data with support for embeddings and semantic search.</p> <pre><code>from agenticrag.stores import TextStore\nfrom agenticrag.types import TextData\n\n# Initialize with persistent vector DB\ntext_store = TextStore(persistent_dir=\"./vector_db\")\n\n# Add text data\ntext_store.add(\n    TextData(\n        id=\"doc_123\",\n        name=\"architecture_overview\",\n        text=\"The system follows a microservice architecture...\",\n        source=\"internal_wiki\"\n    )\n)\n\n# Search similar content\nsimilar_texts = text_store.search_similar(\n    \"system design patterns\", \n    document_name=\"architecture_overview\", \n    top_k=10\n)\n</code></pre>"},{"location":"01_stores/#tablestore","title":"TableStore","text":"<p>Specialized for tabular data like CSVs and dataframes.</p> <pre><code>from agenticrag.stores import TableStore\nfrom agenticrag.types import TableData\n\n# Initialize \ntable_store = TableStore(connection_url=\"sqlite:///agenticrag.db\")\n\n# Add table reference\ntable_store.add(\n    TableData(\n        id=1,\n        name=\"sales_data\",\n        path=\"data/sales_2023.csv\",\n        structure_summary=\"\"\"\n        Sales data with columns:\n        - date (datetime): Transaction date\n        - product_id (int): Product identifier\n        - quantity (int): Units sold\n        - revenue (float): Total revenue\n        - region (str): Sales region\n        \"\"\",\n    )\n)\n</code></pre>"},{"location":"01_stores/#externaldbstore","title":"ExternalDBStore","text":"<p>Interfaces with external databases via connection strings.</p> <pre><code>from agenticrag.stores import ExternalDBStore\n\n# Initialize\nexternal_db_store = ExternalDBStore(connection_url=\"sqlite:///agenticrag.db\")\n\n# Add database connection\nexternal_db_store.add_connection(\n    name=\"production_db\",\n    connection_url=\"postgresql://user:pass@localhost:5432/production\",\n    description=\"Production database with customer and order tables\",\n    tables=[\"customers\", \"orders\", \"products\"]\n)\n</code></pre>"},{"location":"02_loaders/","title":"Loaders","text":"<p>Loaders simplify the process of ingesting data into stores by handling parsing, preprocessing, and metadata generation. They abstract away the complexity of working directly with stores.</p>"},{"location":"02_loaders/#textloader","title":"TextLoader","text":"<p>Handles various text formats including plain text, PDFs, and web content.</p> <pre><code>from agenticrag.loaders import TextLoader\nfrom langchain_google_genai import ChatGoogleGenerativeAI\n\n# Define LLM to utilize automatic description generation and more, you can use any ChatModel from langchain\nllm = ChatGoogleGenerativeAI(\n    model=\"gemini-2.0-flash\",\n    api_key=\"&lt;your_api_key&gt;\",\n)\n\n# Initialize with appropriate stores\ntext_loader = TextLoader(\n    text_store=text_store,  \n    meta_store=meta_store,\n    chunk_size = 2000,\n    chunk_overlap = 200,\n    llm = llm # or leave it empty to use DEFAULT_LLM (Gemini-2.0-flash), we can use llm \n)\n\n# Load PDF with automatic chunking and metadata generation\ntext_loader.load_pdf(\n    path=\"data/research_paper.pdf\"\n)\n\n# Load from web URL\ntext_loader.load_web(\n    url=\"https://example.com/article\",\n    name=\"web_article\"\n)\n</code></pre>"},{"location":"02_loaders/#tableloader","title":"TableLoader","text":"<p>Specializes in loading tabular data with automatic schema detection.</p> <pre><code>from agenticrag.loaders import TableLoader\n\n# Initialize\ntable_loader = TableLoader(\n    table_store=table_store,\n    meta_store=meta_store,\n    persistence_dir=\"./table_data\",\n    llm=llm\n)\n\n# Load CSV with automatic schema inference\ntable_loader.load_csv(\n    path=\"data/customer_data.csv\",\n    name=\"customers\"\n)\n\n# Load from pandas DataFrame\nimport pandas as pd\ndf = pd.read_excel(\"data/financial_report.xlsx\")\ntable_loader.load_dataframe(\n    df=df,\n    name=\"financial_data\",\n)\n</code></pre>"},{"location":"02_loaders/#creating-custom-loaders","title":"Creating Custom Loaders","text":"<p>You can create custom loaders for specialized data sources:</p> <pre><code>from agenticrag.loaders import BaseLoader\nfrom agenticrag.types.exceptions import LoaderError\n\nclass JSONLoader(BaseLoader):\n    def __init__(self, text_store, meta_store):\n        self.text_store = text_store\n        self.meta_store = meta_store\n\n    def load_json(self, path, name, description=None):\n        import json\n        with open(path, 'r') as f:\n            data = json.load(f)\n\n        # Convert to text representation\n        text_content = json.dumps(data, indent=2)\n\n        # Add metadata\n        meta = self.meta_store.add(\n            MetaData(\n                name=name,\n                format=DataFormat.TEXT,\n                description=description or f\"JSON data from {path}\", # or use LLM to generate one\n                source= path\n            )\n        )\n\n        try:\n            json_data = self.text_store.add(\n                TextData(\n                    id=f\"json_{name}\",\n                    name=name,\n                    text=text_content\n                )\n            )\n            return meta\n\n        except Exception as e:\n            self.meta_store.delete(meta.id) # Always evert data from meta store if error occurred while adding in main store.\n            raise LoaderError(\"Error\") from e\n</code></pre>"},{"location":"03_connectors/","title":"Connectors","text":"<p>Connectors establish links to external data sources, particularly databases and APIs, allowing the system to query them without importing all data.</p>"},{"location":"03_connectors/#externaldbconnector","title":"ExternalDBConnector","text":"<pre><code>from agenticrag.connectors import ExternalDBConnector\n\n# Initialize\nconnector = ExternalDBConnector(\n    external_db_store=external_db_store,\n    meta_store=meta_store\n)\n\n# Connect to external database\nconnector.connect_db(\n    name=\"analytics_db\",\n    connection_url_env_var=\"DATABASE_URL\",\n)\n</code></pre>"},{"location":"03_connectors/#custom-connector","title":"Custom Connector","text":"<p>You can create your own data connectors like api connectors by inheriting BaseConnector class and writing custom logic to connect with api, as well as storing that information on store made for your own kind of data.</p> <pre><code>from agenticrag.connectors import BaseConnector\n\nclass RESTApiConnector(BaseConnector):\n    def __init__(self, meta_store, ...):\n        pass\n\n\n    def connect_api(self, name, base_url, auth_method, endpoints, description=None, ...):\n        # Your Custom logic to connect with api\n        pass\n</code></pre>"},{"location":"04_retrievers/","title":"Retrievers","text":"<p>Retrievers extract relevant information from stores based on user queries. They are specialized by data type and retrieval method. They are normally used directly by RAG Agent which orchestrates the workflow, so to avoid retrieved data getting lost in llm communication, we generally provide a persistent_dir where these retrievers save the retrieved data and return a string message saying where retrieved data is instead of actual data.</p>"},{"location":"04_retrievers/#vectorretriever","title":"VectorRetriever","text":"<p>Uses semantic search for text data retrieval.</p> <pre><code>from agenticrag.retrievers import VectorRetriever\n\n# Initialize\nvector_retriever = VectorRetriever(\n    text_store=text_store,\n    persistent_dir=\"./retrieved_data\",\n    top_k=10\n)\n\n# Retrieve relevant text chunks\nresult = vector_retriever.retrieve(\n    query=\"How does multi-head attention work?\",\n    document_name=\"attention_paper\",  # Optional, can search across all documents\n)\n\nprint(result)\n</code></pre>"},{"location":"04_retrievers/#tableretriever","title":"TableRetriever","text":"<p>Specializes in retrieving and processing tabular data.</p> <pre><code>from agenticrag.retrievers import TableRetriever\n\n# Initialize\ntable_retriever = TableRetriever(\n    table_store=table_store,\n    persistent_dir=\"./retrieved_data\"\n)\n\n# Retrieve with filtering and transformation\nresult = table_retriever.retrieve(\n    query=\"Get average revenue by region for Q1 2023\",\n    data_name=\"name\" # name of the data/file in meta store\n)\n\nprint(result)\n</code></pre>"},{"location":"04_retrievers/#sqlretriever","title":"SQLRetriever","text":"<p>Executes SQL queries against external databases.</p> <pre><code>from agenticrag.retrievers import SQLRetriever\n\n# Initialize\nsql_retriever = SQLRetriever(\n    external_db_store=external_db_store,\n    persistent_dir=\"./retrieved_data\"\n)\n\n# Retrieve using natural language which gets converted to SQL\nresult = sql_retriever.retrieve(\n    query=\"Find customers who made purchases over $1000 last month\",\n    db_name=\"production_db\",\n)\n\nprint(result)\n</code></pre>"},{"location":"04_retrievers/#creating-custom-retrievers","title":"Creating Custom Retrievers","text":"<p>You can create custom retrievers for specialized retrieval logic:</p> <pre><code>from agenticrag.retrievers import BaseRetriever\nimport os\n\nclass HybridRetriever(BaseRetriever):\n    def __init__(self, text_store, table_store, persistent_dir):\n        self.text_store = text_store\n        self.table_store = table_store\n        self.persistent_dir = persistent_dir\n        os.mkdir(self.persistent_dir) if not os.path.exists(self.persistent_dir) else None\n\n    @property\n    def name(self):\n        return 'hybrid_retriever'\n\n    @property\n    def description(self):\n        return (\n            f\"This retriever requires a user query in the input and retrieves relevant text chunks by \"\n            f\"doing hybrid text search from database. It then saves those chunks in \"\n            f\"`{self.persistent_dir}/text_data.txt`.\"\n        )\n\n    @property\n    def working_data_format(self):\n        return DataFormat.TEXT\n\n    def retrieve(self, query, table_name):\n        # Your retrieving logic\n        # ...\n        text_results = your_custom_logic()\n\n        # Save combined results\n        output_path = os.path.join(self.persistent_dir, \"hybrid_results.txt\")\n        with open(output_path, \"w\") as f:\n            f.write(\"TEXT RESULTS:\\n\")\n            for text in text_results:\n                f.write(f\"{text.text}\\n\\n\")\n\n\n        return f\"Retrieved hybrid data saved to: {output_path}\"\n</code></pre> <p>Note</p> <p>While creating custom retrievers be extra careful, have clear name, description as well as clear arguments in .retrieve() method. Only take necessary arguments and avoid use of *args and **kwargs, if possible values like top_k which can be set by default should be set in constructor instead of .retrieve()</p>"},{"location":"05_tasks/","title":"Tasks","text":"<p>Tasks are the components that perform operations on retrieved data to accomplish user goals, such as answering questions, generating reports etc.</p>"},{"location":"05_tasks/#questionansweringtask","title":"QuestionAnsweringTask","text":"<p>Answers questions based on retrieved context.</p> <pre><code>from agenticrag.tasks import QuestionAnsweringTask\n\n# Initialize\nqa_task = QuestionAnsweringTask()\n\n# Execute task with retrieved context\nanswer = qa_task.execute(\n    question=\"What are the key benefits of transformer architectures?\",\n    context_file=\"./retrieved_data/text_data.txt\",\n)\n\nprint(answer)\n</code></pre>"},{"location":"05_tasks/#chartgenerationtask","title":"ChartGenerationTask","text":"<p>Creates data visualizations from retrieved data.</p> <pre><code>from agenticrag.tasks import ChartGenerationTask\n\n# Initialize\nchart_task = ChartGenerationTask(save_charts_at=\"./charts\")\n\n# Generate chart from retrieved data\nresult = chart_task.execute(\n    query=\"Create a bar chart showing sales by region\",\n    file_file=\"./retrieved_data/table_data.csv\",\n)\n\nprint(result)\n</code></pre>"},{"location":"05_tasks/#custom-task-example","title":"Custom Task Example","text":"<pre><code>from agenticrag.tasks import BaseTask\nfrom agenticrag.utils.llm import get_default_llm()\n\nclass SentimentAnalysisTask(BaseTask):\n    def __init__(self):\n        pass\n\n    @property\n    def name(self):\n        return \"sentiment_analysis\"\n\n    @property\n    def description(self):\n        return (\n            \"This task takes a Text file path and returns if file content is positive or negative\"\n        )\n\n    def execute(self, context_file):\n        # Read context\n        with open(context_file, 'r') as f:\n            text = f.read()\n\n        # Perform sentiment analysis\n        # (Implementation depends on your preferred NLP approach)\n        is_positive = True # Let's just assume this\n\n        if is_positive:\n            return \"Provided file has positive sentiment with 95% score\"\n\n        else:\n            return \"Provided file has negative sentiment with 10%  positive score\"\n</code></pre> <p>Note</p> <p>Similar to retrieve's .retrieve() method, .execute() should be clear, so much so no llm should be confused when calling this method and when value is returned get clear idea what has been done</p>"},{"location":"06_ragagent/","title":"RAGAgent","text":"<p>The <code>RAGAgent</code> is a high-level controller that orchestrates the complete retrieval-augmented generation (RAG) pipeline. It autonomously selects relevant datasets, appropriate retrievers, and task-specific tools to fulfill user queries using an LLM as the decision-making engine.</p> <pre><code>from agenticrag import RAGAgent\n\n# Initialize the agent with retrievers and task tools\nagent = RAGAgent(\n    persistent_dir=\"./agenticrag_data\",\n    retrievers=[vector_retriever, table_retriever, sql_retriever],\n    tasks=[qa_task, chart_task]\n)\n\n# Load data (if provided retriever's stores don't already have, you can load directly through RAGAgent)\nagent.load_pdf(\"data/research.pdf\", name=\"research_paper\")\nagent.load_csv(\"data/metrics.csv\", name=\"performance_metrics\")\n\n# Run a user query\nresponse = agent.invoke(\n    \"Generate a report on our Q1 performance including a chart of sales by region\"\n)\n\nprint(response.content)\n</code></pre>"},{"location":"06_ragagent/#what-ragagent-does-under-the-hood","title":"\ud83d\udd0d What RAGAgent Does (Under the Hood)","text":"<p>The <code>RAGAgent</code> uses an LLM to perform tool selection, dataset relevance scoring, and task coordination in a multi-step reasoning loop. Here's a breakdown:</p>"},{"location":"06_ragagent/#1-query-understanding-task-selection","title":"1. Query Understanding &amp; Task Selection","text":"<ul> <li>The agent sends the query and the list of available tasks (e.g., QA, charting) to the LLM.</li> <li>The LLM returns the list of tasks it considers relevant.</li> </ul>"},{"location":"06_ragagent/#2-dataset-selection","title":"2. Dataset Selection","text":"<ul> <li>The agent queries the metadata store (<code>MetaStore</code>) to find datasets relevant to the input query.</li> <li>Metadata includes names, descriptions, format etc.</li> </ul>"},{"location":"06_ragagent/#3-retriever-mapping","title":"3. Retriever Mapping","text":"<ul> <li> <p>Based on the selected datasets, the agent chooses appropriate retrievers:</p> </li> <li> <p><code>VectorRetriever</code> for PDFs and text</p> </li> <li><code>TableRetriever</code> for structured tabular data</li> <li><code>SQLRetriever</code> for external databases   or any other custom retrieves for own kind of Data format</li> </ul>"},{"location":"06_ragagent/#4-tool-wrapping","title":"4. Tool Wrapping","text":"<ul> <li>Each retriever and task is wrapped as a <code>StructuredTool</code>, making them callable by the LLM with a schema-based interface.</li> </ul>"},{"location":"06_ragagent/#5-llm-controlled-loop","title":"5. LLM-Controlled Loop","text":"<ul> <li> <p>The LLM receives:</p> </li> <li> <p>Tool metadata (descriptions, names, schemas)</p> </li> <li>Dataset metadata</li> <li>The original user query</li> <li>It responds with which tool to call and what arguments to use.</li> <li>The agent runs the tool and appends the result to the conversation.</li> <li>The loop continues until the LLM issues a <code>final_answer</code> call.</li> </ul>"},{"location":"06_ragagent/#example-decision-flow-simplified","title":"Example Decision Flow (Simplified)","text":"<pre><code>def invoke(self, query):\n    tasks = self._select_tasks(query)\n    datasets = self._select_relevant_data(query)\n    retrievers = self._select_retrievers(datasets)\n\n    tools_dict = wrap_as_structured_tools(retrievers + tasks)\n\n    messages = build_prompt_with_metadata(tools=tools_dict, datasets=datasets, query=query)\n\n    for i in range(max_iterations):\n        tool_call = llm.invoke(messages)\n\n        if tool_call.tool == \"final_answer\":\n            return final_response(tool_call.args[\"answer\"])\n\n        output = tools_dict[tool_call.tool].invoke(tool_call.args)\n        messages.append_output(tool_call, output)\n</code></pre>"},{"location":"06_ragagent/#key-features","title":"Key Features","text":"<ul> <li>LLM-Orchestrated Tool Use: Uses a system prompt + structured tool descriptions to decide what to do.</li> <li>Multi-Step Reasoning: Iteratively calls tools and updates context.</li> <li>Modular Retrieval: Supports text, table, and SQL retrievers out of the box.</li> <li>Pluggable Tasks: Easily add new tasks by implementing the <code>BaseTask</code> interface.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Build powerful Retrieval-Augmented Generation (RAG) applications with minimal or advanced setup using <code>agenticrag</code>.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>Install agenticrag: <pre><code>pip install agenticrag\n</code></pre></li> </ul>"},{"location":"quickstart/#minimal-ragagent-setup","title":"Minimal RAGAgent Setup","text":"<p>This is the simplest way to get started. Just create an agent, load some data (PDFs, webpages), and invoke queries.</p> <pre><code>import os\nfrom agenticrag import RAGAgent\n\n# Set Gemini API Key (required for default LLM)\nos.environ[\"GEMINI_API_KEY\"] = \"&lt;YOUR GEMINI API KEY&gt;\"\n\n# Create agent with default setup\nagent = RAGAgent()\n\n# Load a PDF file\nagent.load_pdf(\n    path=\"data/attention.pdf\",\n    name=\"attention_paper\",\n)\n\n# Load from a website\nagent.load_web(\n    url=\"https://en.wikipedia.org/wiki/Retrieval-augmented_generation\",\n    name=\"rag_wiki\"\n)\n\n# Ask a question\nresponse = agent.invoke(\"What is Retrieval-Augmented Generation?\")\nprint(\"Answer:\", response.content)\nprint(\"Sources:\", [s.name for s in response.datasets])\n</code></pre> <p>Done. Just load and ask.</p>"},{"location":"quickstart/#advanced-multi-source-project","title":"Advanced Multi-Source Project","text":"<p>Build a robust, multi-modal RAG pipeline with fully customizable components.</p> <pre><code>from agenticrag import RAGAgent\nfrom agenticrag.stores import MetaStore, TextStore, TableStore, ExternalDBStore\nfrom agenticrag.retrievers import VectorRetriever, TableRetriever, SQLRetriever\nfrom agenticrag.tasks import QuestionAnsweringTask, ChartGenerationTask\nfrom agenticrag.loaders import TextLoader, TableLoader\nfrom agenticrag.connectors import ExternalDBConnector\nfrom langchain_google_genai import ChatGoogleGenerativeAI\n\n# Initialize LLM\nllm = ChatGoogleGenerativeAI(\n    model=\"gemini-2.0-pro\",\n    api_key=\"&lt;YOUR GEMINI API KEY&gt;\",\n)\n\n# Initialize persistent stores\nmeta_store = MetaStore(\n    connection_url=\"sqlite:///project.db\"\n)\ntext_store = TextStore(\n    persistent_dir=\"./vector_store\", embedding_function=\"default\"\n)\ntable_store = TableStore(\n    connection_url=\"sqlite:///project.db\"\n)\nexternal_db_store = ExternalDBStore(\n    connection_url=\"sqlite:///project.db\"\n)\n\n# Initialize loaders\ntext_loader = TextLoader(\n    text_store, meta_store, chunk_size=100, chunk_overlap=20, llm=llm)\ntable_loader = TableLoader(\n    table_store, meta_store, persistence_dir=\"./tables\", llm=llm)\n\n# Connect external DB\ndb_connector = ExternalDBConnector(external_db_store, meta_store, llm=llm)\n\n# Load data\ntext_loader.load_pdf(\"./docs.pdf\")\ntable_loader.load_csv(\"./data/metrics.csv\")\ndb_connector.connect_db(\n    name=\"analytics\", \n    connection_url_env_var=\"ANALYTICS_DB_URL\"\n)\n\n# Initialize retrievers\nvector_retriever = VectorRetriever(\n    text_store, persistent_dir=\"./retrieved_data\")\ntable_retriever = TableRetriever(\n    table_store, persistent_dir=\"./retrieved_data\")\nsql_retriever = SQLRetriever(\n    external_db_store, persistent_dir=\"./retrieved_data\")\n\n# Initialize tasks\nqa_task = QuestionAnsweringTask()\nchart_task = ChartGenerationTask()\nreport_task = ReportGenerationTask()\n\n# Create the custom agent\nagent = RAGAgent(\n    persistent_dir=\"./project_data\",\n    retrievers=[vector_retriever, table_retriever, sql_retriever],\n    tasks=[qa_task, chart_task, report_task]\n)\n\n# Invoke with a complex prompt\nresponse = agent.invoke(\n    \"What was the average user growth over the last 4 quarters? Also, show a chart comparing user growth and churn rate.\"\n)\n\nprint(\"Answer:\\n\", response.content)\n</code></pre> <p>Tip</p> <p>You can always start with the minimal setup and gradually plug in your own loaders, retrievers, and task modules as your use case grows.</p>"}]}